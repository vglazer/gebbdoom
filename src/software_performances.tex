\vspace{-40pt}
\section{Performance} \label{performances}
There is a convenient and portable way to assess performance. Thanks to the fixed tic duration architecture, a demo can be recorded and played back exactly. With frame skipping disabled, a \cw{-timedemo} will produce the exact same sequence of frames to render regardless of the machine's power. Only wall time will vary.\\
\par
The gold standard of \doom{} benchmarking was created by Anton Ertl around 1994. It consists of playing back DEMO3 from the unregistered version of \doom{} shareware v1.9.\\
\par
\fakedosoutput{timedemo.txt}
\par
Over the last twenty five years, Anton has gathered metrics for hundreds of configurations\footnote{Source: https://www.complang.tuwien.ac.at/misc/doombench.html} of the famous game session recorded by John Romero. The machines tested range from Amiga 1200s up to Core i5s. Because no frames are skipped, the playback duration varies. Upon completion two values are displayed.\\
\par
\fakedosoutput{timedemo_result.txt}
\par

The first value, \cw{gametics}, is the number of game tics rendered. For \cw{demo3} this is always equal to 2134 since it comes from the recorded lump. The second value, \cw{realtics}, represents the wall time in tics that it took to render every frame.\\
\par
 The average frame per second is obtained with the following formula:\\
 \par 
\begin{equation*}
\resizebox{.4 \textwidth}{!} 
{
 $ fps = \frac{gametics}{realtics} * 35 $ 
 }
 \end{equation*}\\

 
In the previous example\footnote{Benchmark machine was a miniPC Unisys CWD 4001 (486DX2-66/CirrusLogic-GD5424).}, the game ran at an average of $\frac{2134}{4268}*35 = 17.5$ fps. \\
\par
This mechanism allows running benchmarks across varying configurations. Since machines from 1994 have become difficult to come by these days, a generous collector named Foone Turing kindly volunteered their impressive fleet of machines. The results of the archaeological-benchmarking session are visible in figure \ref{bnechmarsks}.\\
\par
 The results of the session demonstrate that none of the hardware of the time was able to max out the game. Remember that beyond 35fps there would be no visual improvement since the game logic is hard-coded to run at 35Hz. A machine able to render 70fps video/audio would render the same game frame twice.\\
\par
\begin{figure}[H]
\centering  
\begin{tabularx}{\textwidth}{ L{1}  R{0.3} R{2.4} R{1} R{0.3} }
  \toprule
   \textbf{CPU} & \textbf{Frequency} & \textbf{Graphic card} & \textbf{Bus} & \textbf{fps}\\
  \toprule 
  386DX & 33 & Tseng Labs ET3000    & ISA-8  &  4\\
  386DX\protect\footnotemark & 33 & Cirrus Logic CL-GD5420 & ISA-16 &  7\\
  \toprule 
  486SX & 33 & Tseng Labs ET3000                & ISA-8  &  7\\
  486SX & 33 & Cirrus Logic CL-GD5420           & ISA-16 & 11\\ 
  486SX & 33 & Diamond Stealth (Tseng ET4000)   & VLB    & 15\\
  \toprule 
  486DX2 & 66 & Tseng Labs ET3000               & ISA-8  &  8\\
  486DX2 & 66 & Cirrus Logic CL-GD5420          & ISA-16 & 13\\
  486DX2 & 66 & Diamond Stealth (Tseng ET4000)  & VLB    & 24\\
   \toprule
 \end{tabularx}
\caption{Benchmark with out-of-the-box \doom{} shareware.}
\label{bnechmarsks}
\end{figure}\label{benchmarks}
\footnotetext{For reference, this configuration was able to run Wolfenstein 3D at 20 fps.}
\par
Using out of the box settings for the game, a top of the line machine could barely reach 25 fps\footnote{It would not be until the Pentium when PCI buses came out that \doom{} could be maxed out at 35 fps.}. Notice the importance of the bus, which yields a 3x performance hit/boost. At equal frequencies a 486 provides twice the framerate of a 386.\\
\par






\subsection{Profiling}
Even without special tools, it is possible to gain insight into which parts of the engine are responsible for CPU cycle consumption, thanks to built-in command line parameters.\\
\par
Parameter \cw{-nodraw} skips rendering altogether (but does blit).\\
\par
\par
\fakedosoutput{timedemo_result_nodraw.txt}
\par
Without drawing, the game's framerate improved from 17fps to 878fps.\\
\par
Parameter \cw{-noblit} renders to RAM but doesn't transfer the content to VRAM which is a good way to assess the impact of the bus speed. Because of optimizations described later this parameter was only available on non-DOS versions like on NeXTSTEP.\\
\par
\tcode{timedemo_result_noblit.txt}


\vspace{-10mm}
\subsection{Profiling With A Profiler}
An excellent way of visualizing performance is with a flame graph. These are built by running a program, repeatedly interrupting it, and unwinding the stack starting from the Program Counter to generate a backtrace. This is repeated hundreds of times while playing back a demo. After completion, all backtraces are collected and merged together.\\
\par
 This produces a tree where the width represents 100\% of the time and each level is a function call. It provides a visual breakdown of where the machine spends time during a frame\footnote{This is a wall time-based flamegraph but there are many other kinds, like CPU-cycle based for example.}. On NeXTSTEP, thanks to the multiprocessing capability of the OS it is easy to use \cw{gdb} from a second terminal and gather backtraces. The result is as follows.\\
\par

\drawing{flamegraph}{Flame graph of \cw{./doom -timedemo demo1} on NeXTstation TurboColor}
\par
Obviously, \cw{D\_DoomLoop} accounts for 100\% of the time, with \cw{D\_Display} overwhelmingly dominating\footnote{But keep in mind the NeXTSTEP port did not implement the audio system.}. Gameplay (\cw{TryRunTics}) (isolated column on the very right) is barely visible. In a flame graph, bottlenecks are identified by "mesas" which are high flat plateaus with no children. With that clue, notice the high cost of blitting from framebuffer \#0 to the screen (\cw{Update16}), the horizontal drawing routine (\cw{R\_DrawSpan}) rendering visplanes and the less obvious BSP traversal resulting in vertical drawing routines (\cw{R\_RenderBSPNode}) to render walls/sprites.




On DOS, generating a flame graph is more difficult since it is a single-threaded operating system. However, with a little bit of instrumentation it is possible to get something similar. The following flame graph was generated by instrumenting ten functions.\\
\par
\vspace{4mm}
\drawing{dos_flamegraph}{Flame graph of \doom{} running on DOS}
\par
The DOS flame graph shows that A.I. run in \cw{G\_Ticker} consumes little CPU time. The audio routine \cw{S\_UpdateSounds} is even less taxing since it is barely visible as the tiny red span. This makes sense since the only work it does is to retrieve sound effects and music data from the \cw{.wad} and place it into RAM for the audio card to use.\\
\par
 Something weirder to notice is that, despite being instrumented, \cw{I\_FinishUpdate} is not visible at all whereas it was a huge part of the loop on \NeXTns{}. How can the DOS version transfer a full framebuffer across the bus so fast? As it turns out, the DOS version benefited from heavy optimization, and as a result, did not have to blit at the end of a frame.\\
\par

\subsection{DOS Optimizations}
Given that it was meant to be the money maker, the DOS version received special care. During optimization sessions, John Carmack identified three areas for improvement. One was in the math functions and two had to do with the 3D renderer.\\
 \par
 \fq{An exercise that I try to do every once in a while is to "step a frame" in the game, starting at some major point like common->Frame(), game->Frame(), or renderer->EndFrame(), and step into every function to try and walk the complete code coverage.\\
 \par
  This usually gets rather depressing long before you get to the end of the frame. Awareness of all the code that is actually executing is important, and it is too easy to have very large blocks of code that you just always skip over while debugging, even though they have performance and stability implications.}{John Carmack}
\par




\subsubsection{Math Optimizations}
Fixed-point operations are performed everywhere. The function \cw{FixedMul} is found 124 times in the source code and is called over a thousand times per frame. Along with \cw{FixedDiv2}, it was optimized with inline assembly. The C version "\cw{return ((long long) a * (long long) b) >> 16}" was a function call in Watcom resulting in close to 30 instructions but the assembly version only uses two.\\
\par
\acode{FixedMul.asm}\\
\par
\trivia{There is next to no assembly in \doom. Around 1994, John Carmack even declared that "Assembly language is almost dead". This was without counting on Intel's Pentium, the super-scalar architecture of which would require extra care by Michael Abrash for Quake.}\\


\vspace{-2mm}


\subsubsection{Assembly Wall Renderer Optimization}

The lower-level parts of the engine where are rendered the walls and flats (namely functions \cw{R\_DrawColumn} and \cw{R\_DrawSpan}) were given special attention. These were heavily hand-optimized with gorgeous assembly using all the tricks in the book. Taking a look at \cw{R\_DrawColumn} from \cw{planar.asm} is revealing. The function uses self-modifying code (see reserved value \cw{12345678h} meant to contain the scaling factor, which is patched).
We can also see the loop was unrolled to process up to two pixels at at time (and therefore avoid emptying the i486 prefetch queue because of the \cw{jnz} instruction). Notice the cool trick where register \cw{eax} is reused three times, once as a pointer to the texture source, then as \cw{al} for texel storage (\cw{al}), then as \cw{al} for translated texel (lightmapped) storage again.\\ 
\par
Overall \cw{R\_DrawColumn} yields an amortized 7 instructions per pixel for drawing columns which is remarkable.\\
\par
\trivia{Because \doom{} was designed to be portable, the \cw{.asm} code can be easily turned on/off with a single C \cw{DEFINE}. When disabled the game engine runs the C implementations. This made it easy to benchmark the gain from the \cw{.asm} files. After recompiling and running \cw{timedemo} the 486 DX-2 VLB showed a substantial framerate improvement of 15\%}.

\acode{R_DrawColumn.asm}








\vspace{-28pt}
\subsubsection{Assembly Flat Renderer Optimization}
The engine draws spans in each flat horizontally in order to save perspective correctness calculations. This is a problem since a naive implementation would require to switch VGA plane every pixel via expensive \cw{out} instructions. This approach would kill the framerate.\\
\par
As a result, \cw{R\_DrawSpan} is more involved than \cw{R\_DrawColumn}. Tricks such as self-modifying code are still used but the most interesting optimization is the four inner-loops, one for each VGA plane, so only four \cw{out} instructions are issued per span rendered. Another trick is how two pixels are written at once with one 16-bit write when a span is magnified enough.\\

\fq{The map mask
register only needs to be set once for each vertical column, and four
times for each horizontal row (I step by four pixels in the inner
loop to stay on the same plane, then increment the start pixel and
move to the next plane).}{John Carmack (alt.games.doom - 5/22/94)}








\subsubsection{Direct Framebuffer Access}

A more substantial optimization had to do with layering. On DOS the rules separating the core and the video system were bent. Renderers like the status bar and the automap still function as originally designed but 3D drawing functions such as \cw{R\_DrawColumn} and \cw{R\_DrawSpan} are given direct access to the VGA banks. By bypassing framebuffer \#0, one read and one write per pixel (plus bus transfer) are avoided. Since the menu renderer has to be able to draw on top of everything, it was also granted direct VGA VRAM access. This explain why we saw no \cw{FinishUpdate} "blit" operation when we generated a flamegraph for the DOS version.\\
\par

\fq{It is still a lot of grief, and it pollutes the program quite a bit,
but texture mapping directly to the video memory gives you a fair
amount of extra speed (10\% - 15\%) on most video cards because the
video writes are interleaved with main memory accesses and texture
calculations, giving the write time to complete without stalling.\\
\par
Going to that trouble also gets a perfect page flip, rather than the
tearing you get with main memory buffering.}{John Carmack (alt.games.doom - 5/22/94)}

\acode{R_DrawSpan.asm}


\vspace{-1.25cm}
\section{Performance Tuning}
Despite all the care and optimization, most gamers could not get more than 10 fps with the game out of the box. To help reach a decent framerate, two tuning mechanisms helped to reduce the number of pixels written.
\begin{enumerate}
\item High detail/low detail toggle.
\item Adjust the size of the 3D canvas.
\end{enumerate}
\par
\trivia{These tradeoffs were not specific to the PC. All console ports -- from the "weak" Super Nintendo to the "strong" PlayStation -- used a combination of these two settings.}\\
\par



\section{High/Low detail mode}
The first tuning option was to lower the horizontal resolution using column doubling. In low resolution mode the engine only renders one out of every two columns but it writes them to the framebuffer twice. Given how the 3D renderer dominates runtime, this resulted in a tremendous performance improvement since fewer pixel values are generated but they also don't have to transit the bus.  A performance gain confirmed as the following benchmark shows.\\
\par
 \vspace{0.5cm}
\begin{figure}[H]
\centering  
\begin{tabularx}{\textwidth}{ C{1} C{1} C{1} C{1} } 
  \toprule
  \textbf{High detail resolution} & \textbf{High detail FPS} &  \textbf{Low detail resolution}  & \textbf{Low detail FPS}\\
  \toprule 
320x200  &  19   & 160x200  &       29 \\
320x168  &  20   & 160x168  &       30 \\
288x144  &  23   & 144x144  &       32 \\
256x128  &  25   & 128x128  &       35 \\
224x112  &  28   & 112x112  &       38 \\
192x096  &  31   & 096x096  &       41 \\
160x080  &  35   & 080x080  &       45 \\
128x064  &  40   & 064x064  &       49 \\
096x048  &  45   & 048x048  &       54 \\
  \toprule
\end{tabularx}
\caption{\doom{} performance in low and high detail mode.}
\end{figure}
The benchmark above was conducted on a machine which would have been deemed "top of the line" in 1994, a Unisys CWD 4001 featuring a 486DX2-66 CPU with a Cirrus Logic VLB graphics card. Using low detail mode instead of high detail yields a variable 20\%-50\% performance improvement which brought \doom{} up to a playable framerate on "weaker" PCs running on Intel 386 CPUs.


\vspace{-6pt}
\fullimage{high_res.png}\\
\par
Above, the high resolution is 320x168. Below, in low resolution, it is dropped to 160x168 with odd columns duplicated. The resolution drop is particularly noticeable on the non-magnified sergeant and the door but only because diminished lighting and CRT scaling are disabled for demonstration purposes. In practice the difference was more subtle.\\
\par
With direct access to the VGA banks, "low detail mode" is a completely free optimization without the need to write the same pixel column twice, since the VGA mask is set up to write the same pixel to two banks simultaneously.\\
\par
\vspace{-3pt}
\fullimage{low_res.png} 

\vspace{-30pt}
\section{3D Canvas size adjustment}
Another option to improve the frame rate was to lower the size of the 3D canvas. The player had access to a sliding bar allowing eight sizes to be selected. The slider was a multiplier affecting the variable \cw{numblocks} to produce a value in the range [3,11]. Value 11 was special and hard-coded to be recognized as "full-screen" 320x200.\\
\par
\vspace{4mm}
\ccode{R_ExecuteSetViewSize.c}
\par
It is unknown if anybody had the misfortune and courage to play the game in mode 3. This would have been an achievement in itself.\\
\par
\drawing{lod}{The nine 3D canvas configurations.}
\par
\trivia{id shipped \doom{} by default in "high detail" with canvas size \cw{9}.}

\begin{figure}[H]
\centering  
\begin{tabularx}{\textwidth}{ R{1}  R{1} R{1} R{1}  R{1.4}  R{0.6} }
  \toprule
  \textbf{numblocks} & \textbf{Width} & \textbf{Height} & \textbf{\# Pixels} & \textbf{\# Pixels \%} & \textbf{fps}\\
  \toprule 

 0xB & 320 & 200 & 64,000 & 100 & 19 \\
 0xA & 320 & 168 & 53,760 &  84 & 20 \\
 0x9 & 288 & 144 & 41,472 &  64 & 23 \\
 0x8 & 256 & 128 & 32,768 &  52 & 25 \\
0x7 & 224 & 112 & 25,088 &  39 & 28 \\
 0x6 & 192 & 96 & 18,432 &  28 & 31  \\
 0x5 & 160 & 80 & 12,800 &  20 & 35  \\
 0x4 & 128 & 64 &  8,192 &  12 & 40  \\
 0x3 &  96 & 48 &  4,608 &   7 & 45  \\
   \toprule
\end{tabularx}
\caption{Benchmark of performance gain vs 3D canvas size.\protect\footnotemark}
\end{figure}

\footnotetext{Benchmarked on a miniPC Unisys CWD 4001 (486DX2-66/CirrusLogic-GD5424, 8MiB RAM).}
\par
Gains are not as substantial as the detail level. Reducing the 3D canvas size by 50\% yields only a 31\% improvement yet the visible area is so small it is almost not worth it.\\

\par
{
\setlength{\belowcaptionskip}{-10pt}
\cfullimage{shipped_config}{\doom{} out-of-the-box configuration: Mode 9, High detail}
}


\section{Maxing out \doom{}}
As we saw on page~\pageref{benchmarks}, none of the PCs available when \doom{} was released were able to max out the gameplay at 35fps. While the Intel Pentium 60Mhz and 66Mhz were around since March 1993, they were still very expensive by December 1993 (\$675\footnote{\$1,529 as of 2025!}). Realistically, few people enjoyed \doom{} with a maxed out framerate during the '93 winter break.\\
\par
While the twenty-something frames per second of a top-of-the-line 486 DX2-66Mhz do not sound like a lot by today standards, when monitors reach 240Hz, back then it was considered a comfortable amount and the game was praised for its speed. It would take a year for machines such at the 486 DX4-100Mhz (released October 1994) and Pentium 75 (also released October 1994) to play at 35fps in mode 9. It would take even longer for machines to max-out \doom{} in mode B as seen in the partial reproduction of Anton Ertl's benchmark on the opposite page\footnote{Source: https://www.complang.tuwien.ac.at/misc/doombench.html}.\\
\par
\trivia{Playing music and sound effects in \doom{} has a big impact on performances. Even a 486 DX2 66Mhz will experience a 13\% performance difference between nosound and when a Sound Blaster Pro is running. The penalty is due to music notes but especially audio samples transiting on the bus.}\\
\par






\subsection{FastDOOM}

In June 2020, developer Victor "Viti95" Nieto started to work on project FastDDOM with the goal of optimizing the \doom{} engine as much as possible using modern technology. They managed to increase the framerate by roughly 30\% over the next four years. One of the most noteworthy optimization was three lines in the HUD drawing routine.\\
\par

\ccode{crispy.c}
\par
The original engine always drew the percentage numbers in the HUD, even if they had not changed between frames. This was an expensive operation since these numbers were first drawn into a scrap pad and then copied to the rendering target. This simple noop optimization improved the framerate by nearly 20\% (from 22.38fps to 25.45fps on a reference 486 DX2-66Mhz PC).
That "magic trick" taken directly from "Crispy \doom{}" port proved once again Terje Mathisen's famous email signature.\\
\par
\fq{Almost all programming can be viewed as an exercise in caching.}{Terje Mathisen}\\
\par
\vspace{4mm}

\begin{figure}[H]
\centering  
\tcode{doom_benchmark.txt}
\caption{DOOM benchmark (mode 9, no sound) from Anton Ertl's \doom{} page.}
\end{figure}
